以前封装http方法需要使用2个类来实现 一般都是一个Api 一个 Action  

现在使用@suc/query装饰器来进行封装 理论上一个类就能够实现原先api 和 action的功能  

代码是基于typescript写的 但是js里也能用 可参照example中代码

#### 缺点:  
* 一个class 只能设置一个host和prefix
* 没有判断输入的url 是否是完整路径 所有的url都会被拼接上host和prefix

以下是参数讲解
```
//example 1
@Query({
    host: "http://localhost:3333",
    prefix: "",
    autoPrefix: true
})
class Api {
	
    constructor(config) {
        if(config) {
            this.host = config.host;
            this.prefix = config.prefix;
        }
    }
	
}

let api = new Api({prefix = "", host = ""})
```
#### @Query 是设置初始配置的  
参数一共有3个,
* autoPrefix默认是true autoPrefix为true时 所有访问的url都会  
* host 默认为 "."  
* prefix 默认为 ""  

在web端中建议只设置prefix为"/api",方便开发.
因为移动端的特殊性,所以需要设置host  
host和prefix 会被实例化后的对象内部的host和prefix覆盖

```
@Get()
getUserDetail(){
    return "/rest/user/{userId}";
}

@Post()
updateUserDetail(){
    return "/rest/user/{userId}";
}
```
#### @Get 的多种输入参数说明,必须和@Query搭配使用  
* @Get()  @Get(url) 
装饰器没有任何输入值是就会把装饰器装饰的函数的返回值作为url,同时 会把url中的{}内的变量替换成实际调用时传入
的数据中通字段名的值,注意不要写成{{}} 或者 ${},主要{}内部不支持表达式,但是支持a.b.c这样的对象属性,
不支持`a["b"]`这样的,因为这个替换方法不是使用模板引擎的.为了轻量级,所以自己实现的正则替换方法.
* @Get(url,format)  
第二个尝试是format函数,前端经常是想写页面再写接口,然后对接.所以在写页面时前端自己定义的变量在对接接口时就毫无
用处,都要大改.这个时候可以使用format函数对后台返回的数据做预处理,变成前端自己定义的类型,直接在页面展示,理论上
对接接口和后台改变接口时不需要对页面进行改动直接修改format就可以了.  
format函数不是必填的,根据需求自己增加
* Get(args,format)  
第一个args中有url,format,同时args.format会被第二个参数format覆盖

#### @Post 参数与@Get 基本相同,就是调用的方式不同

#### 函数调用

```
let api = new Api();

api
    .getUserDetail({
        params:{
        	
        },
        format(),
        config:{
            params:{

            }
        }
    })
    .then()
    .catch()
    
api
    .updateUserDetail({
        params:{},
        format(),
        data:{},
        config:{
            params
        }
    })
    .then()
    .catch()

```
* url中的{}会在params对象中匹配,同时params和config.params会合并,params中和config.params中同名的属性会被
config.params里的覆盖.  
* format函数会覆盖@Get 和 @Post中定义的format  
* post和get的区别就是 只是post多了data.


 