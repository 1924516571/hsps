import "reflect-metadata";
import axios from 'axios';
import isString from "lodash/isString";
import isObject from 'lodash/isObject';
import isFunction from 'lodash/isFunction';

export type Format = (args: any) => any;

export type HttpType = "get" | "get_path" | "post_path" | "post"

export type QueryBody = any;

export class ApiInterface {

}

export interface ApiInterface {
    host: string;
    prefix: string;
}

export class httpConfig {

}

export interface httpConfig {

    type: HttpType;

    url: string;

    old?(): string;

    format?: Format

}

export class ApiConfig {
}

export interface ApiConfig {
    prefix?: string,
    host?: string
}

export class QueryHttpConfig<T extends Object> {

}

export interface QueryHttpConfig<T extends Object> {
    params?: T
}

export class QueryHttpResponse<T> {

}

export interface QueryHttpResponse<T> {
    data: T;
}

export class QueryHttp {

}

export interface QueryHttp {
    get(url: string, config?: QueryHttpConfig<Object>): Promise<QueryHttpResponse<any>>;

    post(url: string, data: any, config?: QueryHttpConfig<Object>): Promise<QueryHttpResponse<any>>;
}

export class QueryConfig {

}

export interface QueryConfig extends ApiConfig {
    http?: QueryHttp,
    autoPrefix?: boolean
}

export class QueryArgs {

}

export interface QueryArgs {
    format?: Format;
    config?: QueryHttpConfig<Object>,
    params?: Object,
}

export class QueryPostArgs<T extends QueryBody> {

}

export interface QueryPostArgs<T extends QueryBody> extends QueryArgs {
    data?: T,
}

export class QueryPostParams<T extends QueryBody, U extends Object> {

}

export interface QueryPostParams<T extends QueryBody, U extends Object> extends QueryPostArgs<T> {
    params?: U;
}

export class QueryGetArgs<T extends Object> {

}

export interface QueryGetArgs<T extends Object> extends QueryArgs {
    params?: T,
    config?: QueryHttpConfig<T>
}

export class QueryGetParams {

}

export interface QueryGetParams extends QueryArgs {

}

function pupa(tpl: string, data: Object): string {
    if (typeof tpl !== 'string') {
        throw new TypeError(`Expected a string in the first argument, got ${typeof tpl}`);
    }

    if (typeof data !== 'object') {
        throw new TypeError(`Expected an Object/Array in the second argument, got ${typeof data}`);
    }

    const re = /{(.*?)}/g;

    return tpl.replace(re, (_: any, key: string): string => {
        let ret: any = data;

        for (const prop of key.split('.')) {
            ret = ret ? ret[prop] : '';
        }

        return ret || '';
    });
}

function Get(): MethodDecorator;
function Get(format: Format): MethodDecorator;
function Get(url: string, format?: Format): MethodDecorator;
function Get(config: { url: string, format?: Format }, format?: Format): MethodDecorator;
function Get(a?: any, b?: any) {
    return CreatePostGet('get', a, b)
}

function Post(): MethodDecorator;
function Post(format: Format): MethodDecorator;
function Post(url: string, format?: Format): MethodDecorator;
function Post(config: { url: string, format?: Format }, format?: Format): MethodDecorator;
function Post(a?: any, b?: any) {
    return CreatePostGet('post', a, b)
}

function CreatePostGet(typePrefix: "post" | "get", a?: any, b?: any): MethodDecorator {
    return (target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) => {
        let url = "", type: string = typePrefix, old, format;
        Reflect.defineMetadata(propertyKey, propertyKey, target);
        if (isObject(a) && !isFunction(a)) {
            url = a.url;
            if (a.format) {
                format = a.format;
            }
            type = typePrefix + "_path"
        } else if (isString(a)) {
            url = a;
            type = typePrefix + "_path"
        }

        if (isFunction(a) && !b) {
            format = a;
        } else if (a && isFunction(b)) {
            format = b;
        }
        if (type === typePrefix) {
            old = descriptor.value;
        }
        let config = {type, url, old, format};
        Reflect.defineMetadata(propertyKey, config, target, 'method');
    }
}

const defaultConfig: QueryConfig = {
    autoPrefix: true,
    prefix: "",
    host: "."
};

function preUrl(url: any, config?: QueryConfig): string {
    let prefix = "";
    if (config && config.autoPrefix) {
        prefix = (config.host ? config.host : "") + (config.prefix ? config.prefix : "");
    }
    if (isString(url)) {
        return prefix + url;
    } else {
        throw Error("url not available")
    }
}

function preConfig(args?: QueryArgs): QueryHttpConfig<Object> {
    if (args) {
        let config = Object.assign({}, args.config || {});
        config.params = Object.assign({}, args.params || {}, config.params || {});
        return config;
    } else {
        return {params: {}};
    }
}

function preDefer(defer: Promise<QueryHttpResponse<any>>, format?: Format): Promise<any> {
    if (isFunction(format)) {
        return new Promise((resolve, reject) => {
            defer
                .then((res: any) => {
                    res.data = format(res.data);
                    resolve(res);
                })
                .catch((e) => {
                    reject(e);
                })
        })
    } else {
        return defer;
    }
}

function preFormat(a?: any, b?: any): any {
    return b && isFunction(b.format)
        ? b.format
        : (
            a && isFunction(a.format)
                ? a.format
                : undefined
        )
}

function preData(a?: any): any {
    if (a && a.data) {
        return a.data;
    }
}

function configMerge(qconfig: QueryConfig, q: any) {
    if (q.prefix) {
        qconfig.prefix = q.prefix;
    }
    if (q.host) {
        qconfig.host = q.host;
    }
    return qconfig;
}

export function Query(config?: QueryConfig): ClassDecorator {
    return function (target: any): any {
        return function () {
            let q = new target(...arguments);
            let p = Reflect.getMetadataKeys(q);
            let qconfig: QueryConfig = Object.assign({}, defaultConfig, config || {});
            let http: QueryHttp;
            if (q["http"]) {
                http = q['http'];
            } else if (config && config["http"]) {
                http = config["http"];
            } else {
                http = axios;
            }
            for (let k of p) {
                let config: httpConfig = Reflect.getMetadata(k, q, 'method');
                if (config.type.includes("get")) {
                    q[k] = function () {
                        let url;
                        let ajaxConfig = preConfig(arguments[0]);
                        if (config.type === 'get_path') {
                            url = config.url;
                        } else if (config.type === 'get') {
                            if (config.old) {
                                url = Reflect.apply(config.old, this, arguments);
                            } else {
                                return Promise.reject({
                                    message: `${k} get function not found`
                                })
                            }
                        } else {
                            return Promise.reject({
                                message: "type not found"
                            })
                        }
                        url = pupa(preUrl(url, configMerge(qconfig, q)), ajaxConfig.params ? ajaxConfig.params : {});
                        return preDefer(http.get(url, ajaxConfig), preFormat(config, arguments[0]))
                    }
                } else if (config.type.includes('post')) {
                    q[k] = function () {
                        let url;
                        let ajaxConfig = preConfig(arguments[0]);

                        if (config.type === 'post_path') {
                            url = config.url;
                        } else if (config.type === 'post') {
                            if (config.old) {
                                url = Reflect.apply(config.old, this, arguments);
                            } else {
                                return Promise.reject({
                                    message: `${k} post function not found`
                                })
                            }
                        } else {
                            return Promise.reject({
                                message: "type not found"
                            })
                        }
                        url = pupa(preUrl(url, configMerge(qconfig, q)), ajaxConfig.params ? ajaxConfig.params : {});
                        return preDefer(
                            http.post(url, preData(arguments[0]), ajaxConfig),
                            preFormat(config, arguments[0])
                        )
                    }
                }
            }
            return q;
        }
    }
}


export {
    Get,
    Post
};
export default Query;
