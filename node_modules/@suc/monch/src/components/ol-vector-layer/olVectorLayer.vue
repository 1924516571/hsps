<script>
    import {transformStyle} from "../../utils/helpers";
    import VectorLayer from "ol/layer/Vector";
    import eventMixins from '../../mixins/layerEvent';

    export default {
        name: "olVectorLayer",
        render(h) {
            let childNodes = [];
            if(this.$slots.default) {
                childNodes = childNodes.concat(this.$slots.default);
            }
            if(this.$scopedSlots.event) {
                const nodes = this.$scopedSlots.event({
                    selectFeature: this.selectFeature,
                    moveFeature: this.moveFeature
                });
                childNodes = childNodes.concat(nodes);
            }
            return h('div', {
                    class: 'ol-vector-layer',
                    style: {
                        display: 'none !important'
                    }
                },
                childNodes
            );
        },
        mixins: [eventMixins],
        inject: ['getMap'],
        provide: function () {
            return {
                getLayer: this.getLayer
            }
        },
        props: {
            /**
             *  A CSS class name to set to the layer element.
             */
            className: {
                type: String,
                default: 'ol-layer'
            },
            opacity: {
                type: Number,
                default: 1
            },
            visible: {
                type: Boolean,
                default: true
            },
            extent: {
                type: Array,
                validator: value => value.length === 4
            },
            zIndex: {
                type: Number,
                default: 0
            },
            minResolution: Number,
            maxResolution: Number,
            minZoom: Number,
            maxZoom: Number,
            renderOrder: Function,
            renderBuffer: {
                type: Number,
                default: 100
            },
            declutter: {
                type: Boolean,
                default: false
            },
            layerStyle: [Object, Array, Function], // 图层样式
            updateWhileAnimating: {
                type: Boolean,
                default: false
            },
            updateWhileInteracting: {
                type: Boolean,
                default: false
            },
            name: String  // 图层名称
        },
        data() {
            return {
                layer: null
            }
        },
        watch: {
            opacity(opacity) {
                if (this.layer && this.layer.getOpacity() !== opacity) {
                    this.layer.setOpacity(opacity);
                }
            },
            extent(extent) {
                if (this.layer && this.layer.getExtent() !== extent) {
                    this.layer.setExtent(extent);
                }
            },
            /**
             *  The minimum resolution (inclusive) at which this layer will be visible.
             */
            minResolution(minResolution) {
                if (this.layer && this.layer.getMinResolution() !== minResolution) {
                    this.layer.setMinResolution(minResolution);
                }
            },
            /**
             *  The maximum resolution (exclusive) below which this layer will be visible.
             */
            maxResolution(maxResolution) {
                if (this.layer && this.layer.getMaxResolution() !== maxResolution) {
                    this.layer.setMaxResolution(maxResolution);
                }
            },
            /**
             *  The minimum view zoom level (exclusive) above which this layer will be visible.
            */
            minZoom(minZoom) {
                if (this.layer && this.layer.getMinZoom() !== minZoom) {
                    this.layer.setMinZoom(minZoom);
                }
            },
            /**
             *  The maximum view zoom level (inclusive) at which this layer will be visible.
             */
            maxZoom(maxZoom) {
                if (this.layer && this.layer.getMaxZoom() !== maxZoom) {
                    this.layer.setMaxZoom(maxZoom);
                }
            },
            zIndex(zIndex) {
                if (this.layer && this.layer.getZIndex() !== zIndex) {
                    this.layer.setZIndex(zIndex);
                }
            },
            visible(visible) {
                if (this.layer && this.layer.getVisible() !== visible) {
                    this.layer.setVisible(visible);
                }
            },
            layerStyle: {
                handler(style) {
                    if(this.layer) {
                        const layerStyle = transformStyle(style);
                        this.layer.setStyle(layerStyle);
                    }
                },
                deep: true
            }
        },
        methods: {
            createLayer(map) {
                let style = null;
                if (this.layerStyle) {
                    style = transformStyle(this.layerStyle);
                }
                let options = {
                    className: this.className,
                    opacity: this.opacity,
                    visible: this.visible,
                    extent: this.extent,
                    zIndex: this.zIndex,
                    minResolution: this.minResolution,
                    maxResolution: this.maxResolution,
                    minZoom: this.minZoom,
                    maxZoom: this.maxZoom,
                    renderOrder: this.renderOrder,
                    renderBuffer: this.renderBuffer,
                    declutter: this.declutter,
                    updateWhileAnimating: this.updateWhileAnimating,
                    updateWhileInteracting: this.updateWhileInteracting,
                }

                if (style) {
                    options.style = style;
                }
                this.layer = new VectorLayer(options);

                if (this.name) {
                    this.layer.set('name', this.name);
                }
                this.layer.set('layerClass', 'vectorLayer');
                this.resolve(this.layer);   //getLayer
                map.addLayer(this.layer);
            },
            init() {
                let vm = this;
                vm.getMap().then((map) => {
                    vm.map = map;
                    vm.createLayer(map);
                    this.handleEvent(map);
                })
            },
            getLayer() {
                return this.promise;
            }
        },
        created() {
            const vm = this;
            vm.promise = new Promise(function (resolve) {
                vm.resolve = resolve;
            })
        },
        mounted() {
            this.init();
        },
        beforeDestroy() {
            const vm = this;
            vm.getMap().then((map) => {
                map.removeLayer(vm.layer);
                vm.layer = null;
            });
        }
    }
</script>
