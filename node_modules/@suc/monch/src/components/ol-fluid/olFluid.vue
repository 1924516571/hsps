<template>
    <div class="vueol-fluid" style="display: none;"></div>
</template>
<script>
    import {unByKey} from "ol/Observable";
    import {olMapDefaults} from '../../utils/olMapDefaults';
    import {Fluid,MatrixFluid,ShortFluid} from '../../utils/fluid';

    export default {
        name: 'ol-fluid',
        inject: ['getMap'],
        props: {
            options: {
                type: Object,
                default() {
                    return {}
                }
            },
            points:{
                type: Array,
                default() {
                    return []
                }
            },
            edge:{
                type: Array,
                default() {
                    return []
                }
            },
            extremum: {
                type: Object,
                default() {
                    return {
                        maxx: 0,
                        maxy: 0,
                        minx: 0,
                        miny: 0
                    }
                }
            },
            lonlen: {
                type: Number,
                default: 0
            },
            latlen: {
                type: Number,
                default: 0
            },
            refresh: {
                type: Boolean,
                default: false
            }
        },
        data() {
            return {
                fluid: null,
                canvas:null,
                fluidData:[],
                dataInfo:{},
                moveendKey:null
            }
        },
        watch: {
            refresh: {
                handler() {
                    const vm = this;
                    vm.getMap().then(map => {
                        vm.makeData();
                        vm.update(map);
                    })
                }
            }
        },
        mounted() {
            this.init();
        },
        methods: {
            init() {
                this.getMap().then((map) => {
                    if (this.moveendKey) {
                        unByKey(this.moveendKey)
                    }
                    this.moveendKey=map.on('moveend', ()=>{
                        if(!!this.canvas){
                            this.draw(map);
                        }
                    });
                    // this.update(map);
                    window.addEventListener('resize',this.onresize);
                })
            },
            update(map) {
                const viewProjection = map.getView().getProjection().getCode();
                const defaults = olMapDefaults.getDefaults();

                let {canvas,fluid,dataInfo} = this;
                if(!!canvas){
                    fluid.stop();
                    map.getViewport().removeChild(canvas);
                }
                canvas =this.canvas = document.createElement('canvas');
                canvas.id = this.options.fluid || "windCanvas";
                canvas.width = map.getSize()[0];
                canvas.height = map.getSize()[1];
                canvas.style.position = 'absolute';
                canvas.style.top = 0;
                canvas.style.left = 0;
                map.getViewport().appendChild(canvas);
                if(this.options.type==='matrix'){
                    fluid = this.fluid = new MatrixFluid({
                        map: map,
                        canvas: canvas,
                        data: dataInfo,
                        age:this.options.age,
                        rate:this.options.rate,
                        multi:this.options.multi,
                        weight:this.options.weight,
                        colorful:this.options.colorful,
                        colorMap:this.options.colorMap,
                        lineWidth:this.options.lineWidth,
                        fillStyle:this.options.fillStyle
                    });
                }else if(this.options.type==='short'){
                    fluid = this.fluid = new ShortFluid({
                        map: map,
                        canvas: canvas,
                        age:this.options.age,
                        rate:this.options.rate,
                        multi:this.options.multi,
                        color:this.options.color,
                        lineWidth:this.options.lineWidth,
                        fillStyle:this.options.fillStyle,
                        edge:this.edge,
                        num:this.fluidData.length,
                        jizhi:this.extremum
                    });
                }else{
                    fluid = this.fluid = new Fluid({
                        map: map,
                        canvas: canvas,
                        data: dataInfo,
                        age:this.options.age,
                        rate:this.options.rate,
                        multi:this.options.multi,
                        weight:this.options.weight,
                        colorful:this.options.colorful,
                        colorMap:this.options.colorMap,
                        lineWidth:this.options.lineWidth,
                        fillStyle:this.options.fillStyle
                    });
                }
                let options = {
                    size: this.options.lineWidth || (this.options.type==='short'?6.8:1),
                    color: this.options.strokeStyle || (this.options.type==='short'?'rgba(255,255,255,0.6)':'rgba(71,160,233,0.8)'),
                };
                fluid.change(options);
                this.draw(map);
                map.getView().on('propertychange',()=>{
                    fluid.stop();
                    // $(canvas).hide();
                });

            },
            draw(map){
                let {canvas,fluid} = this;
                // $(canvas).show();
                let bounds = map.getView().calculateExtent();
                let _min = [bounds[0], bounds[1]];
                let _max = [bounds[2], bounds[3]];
                let py = map.getPixelFromCoordinate([bounds[0], bounds[3]]); //经纬度转成屏幕坐标
                canvas.style.left = py[0] + 'px';
                canvas.style.top = py[1] + 'px';
                let points = this.invertLatLon(py,map); //所有站点经纬度转为canvas坐标
                let min = map.getPixelFromCoordinate(_min);
                let max = map.getPixelFromCoordinate(_max);
                let extent = [
                    [min[0] - py[0], max[1] - py[1]],
                    [max[0] - py[0], min[1] - py[1]]
                ];
                fluid.start(extent, points);
            },
            invertLatLon(py,map){
                let {fluidData,dataInfo} = this;
                let points = [];
                if(this.options.type==='matrix'){
                    fluidData.forEach((station)=>{
                        let px = map.getPixelFromCoordinate([station[1], station[0]]);
                        points.push({
                            x: px[0]-py[0],
                            y: px[1]-py[1],
                            speedx: station[2],
                            speedy: station[3]
                        });
                    });
                    return points;
                }else if(this.options.type==='short'){
                    fluidData.forEach(function (station) {
                        var px = map.getPixelFromCoordinate([station[0],station[1]]);
                        points.push({
                            x: px[0]-py[0],
                            y: px[1]-py[1],
                            angle: station[2]
                        });
                    });
                    return points;
                }else{
                    fluidData.forEach(function (station) {
                        let coord = [station[1],station[0]];
                        let px = map.getPixelFromCoordinate(coord);
                        let x=px[0]-py[0];
                        let y=px[1]-py[1];
                        if(x<dataInfo.minx || dataInfo.minx=='initial'){
                            dataInfo.minx=x;
                        }else if(x>dataInfo.maxx || dataInfo.maxx=='initial'){
                            dataInfo.maxx=x;
                        }
                        if(y<dataInfo.miny || dataInfo.miny=='initial'){
                            dataInfo.miny=y;
                        }else if(y>dataInfo.maxy || dataInfo.maxy=='initial'){
                            dataInfo.maxy=y;
                        }
                        points.push({
                            x: x,
                            y: y,
                            speedx: station[2],
                            speedy: -station[3],
                            info:station
                        });
                    });
                    dataInfo.xs=(dataInfo.maxx-dataInfo.minx)/dataInfo.num;
                    dataInfo.ys=(dataInfo.maxy-dataInfo.miny)/dataInfo.num;
                    let doints={};
                    points.forEach(function(point){
                        let i=Math.floor((point.x-dataInfo.minx)/dataInfo.xs);
                        let j=Math.floor((point.y-dataInfo.miny)/dataInfo.ys);
                        if(doints['a'+i]){
                            if(doints['a'+i]['a'+j]){
                                doints['a'+i]['a'+j].push(point)
                            }else{
                                doints['a'+i]['a'+j]=[point]
                            }
                        }else{
                            doints['a'+i]={};
                            doints['a'+i]['a'+j]=[point]
                        }
                    });
                    return doints;
                }
            },
            makeData(){
                this.fluidData=this.points.slice(0);
                this.dataInfo.lonlength=this.lonlen;
                this.dataInfo.latlength=this.latlen;
                this.dataInfo.minx='initial';
                this.dataInfo.maxx='initial';
                this.dataInfo.miny='initial';
                this.dataInfo.maxy='initial';
                this.dataInfo.num=this.options.num || 50;
            },
            onresize(){
                this.getMap().then(map => {
                    if(!!this.canvas){
                        this.update(map);
                    }
                })
            }
        },
        beforeDestroy() {
            const vm = this;
            if (vm.moveendKey) {
                unByKey(vm.moveendKey)
            }
            vm.getMap().then((map) => {
                if(!!vm.canvas){
                    if(vm.fluid){
                        vm.fluid.stop();
                    }
                    map.getViewport().removeChild(vm.canvas);
                }
                window.removeEventListener('resize',vm.onresize)
            })
        }
    }
</script>