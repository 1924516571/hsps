<template>
    <div class="vueol-path" style="display: none;"></div>
</template>
<script>
    import {Vector as VectorLayer} from 'ol/layer';
    import {Vector as VectorSource} from 'ol/source';
    import {olMapDefaults} from '../../utils/olMapDefaults'
    import {
        createFeature, createStyle, isDefined, deepClone,
        getArcPoints, coordinateTransform, calcRadiusAccurate
    } from '../../utils/helpers'
    import layerMixins from "../../mixins/vectorLayer";

    export default {
        name: 'ol-path',
        inject: ['getMap'],
        mixins: [layerMixins],
        props: {
            options: {
                type: Object,
                required: true
            },
            projection: {
                type: String,
                default: 'EPSG:4326'
            }
        },
        data() {
            return {
                feature: null
            }
        },
        watch: {
            options: {
                handler() {
                    const vm = this;
                    vm.getMap().then(map => {
                        vm.update(map);
                    })
                },
                deep: true
            }
        },
        mounted() {
            this.init();
        },
        methods: {
            init() {
                this.getMap().then((map) => {
                    this.createLayer(map, 'pathLayer');
                    this.update(map);
                })
            },
            /**
             *  @description: 通过经纬度和距离，求当前地图坐标系下的单位长度
             *  @param viewProjection 当前地图坐标系
             *  @param distance 距离（米）
             *  @param center 中心点经纬度
             *  @return
             *  @author: xiarx
             *  @date 2020/10/10 18:05
             */
            getRadius(viewProjection, distance, center) {
                if(this.projection==='pixel') {
                    return distance;
                }
                const coords = coordinateTransform(center, this.projection, 'EPSG:4326');
                return calcRadiusAccurate(coords, distance, viewProjection);
            },
            update(map) {
                const viewProjection = map.getView().getProjection().getCode();
                const defaults = olMapDefaults.getDefaults();

                let defaultStyle = defaults.styles.feature;

                if (this.feature) {
                    if (this.options.type == "Circle") {
                        let data = deepClone(this.options);
                        if(this.projection!="pixel") {
                            data.coords = coordinateTransform(data.coords, this.projection, viewProjection);
                            data.radius = this.getRadius(viewProjection, data.radius, this.options.coords);
                        }
                        this.feature.getGeometry().setCenterAndRadius(data.coords, data.radius);
                    } else if(this.options.type == "Sector"){
                        let data = deepClone(this.options);
                        if(this.projection!="pixel") {
                            data.coords = coordinateTransform(data.coords, this.projection, viewProjection);
                            data.radius = this.getRadius(viewProjection, data.radius, this.options.coords);
                        }
                        let coords = getArcPoints(data.coords, data.radius, data.startAngle, data.endAngle);
                        coords.push(data.coords, coords[0]);
                        this.feature.getGeometry().setCoordinates([coords]);
                    }else{
                        this.feature.getGeometry().setCoordinates(this.options.coords);

                        if (this.projection != 'pixel') {
                            this.feature.getGeometry().transform(this.projection, viewProjection);
                        }
                    }

                    //样式更新
                    let style = this.options.style?deepClone(this.options.style):defaultStyle;
                    if (isDefined(style)) {
                        if (style instanceof Array) {
                            let len = style.length;
                            for (let i = 0; i < len; i++) {
                                style[i] = createStyle(style[i]);
                            }
                        } else {
                            style = createStyle(style);
                        }

                        this.feature.setStyle(style);
                    }
                } else {
                    let data = deepClone(this.options);
                    data.style = data.style || defaultStyle;
                    data.projection = this.projection;
                    if (this.options.radius) {
                        if(this.projection!="pixel") {
                            data.coords = coordinateTransform(data.coords, this.projection, viewProjection);
                            data.radius = this.getRadius(viewProjection, data.radius, this.options.coords);
                            data.projection = viewProjection;
                        }
                    }
                    this.feature = createFeature(data, viewProjection);
                    this.source.addFeature(this.feature);
                    this.$emit('create-end', this.feature);
                }
            }
        },
        beforeDestroy() {
            const vm = this;
            vm.getMap().then((map) => {
                let source = vm.source;
                source.getFeatures().forEach(function (f) {
                    let s = f.getStyle();
                    s = null;
                    f = null;
                })
                source.clear();
                source = null;
                map.removeLayer(vm.layer);
            })
        }
    }
</script>
