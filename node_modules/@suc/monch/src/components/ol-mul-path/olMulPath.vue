/*
* 多个feature加载 比使用多个olPath组件性能高
* 并且对交互基本没有要求
* 所以特意为此写了一个组件
* type种类Point, LineString, MultiLineString, Polygon等
*/
<template>
    <div class="vueol-mulpath" style="display: none;">
        <slot :selectFeature="selectFeature" :moveFeature="moveFeature"></slot>
    </div>
</template>
<script>
    import {Point, LineString, Circle, Polygon} from "ol/geom"
    import {
        createFeature,
        coordinateTransform,
        calcRadiusAccurate,
        transformStyle
    } from '../../utils/helpers';
    import eventMixins from '../../mixins/layerEvent';
    import layerMixins from '../../mixins/vectorLayer';

    export default {
        name: 'ol-mul-path',
        mixins: [eventMixins, layerMixins],
        inject: ['getMap'],
        props: {
            grids: {
                type: Array,
                required: true,
                default() {
                    return []
                }
            },
            selectFeatureId: [String, Number],
            projection: {
                type: String,
                default: 'EPSG:4326'
            }
        },
        data() {
            return {
                layerName: 'mulPath',
                selectFeature: null
            }
        },
        watch: {
            grids: {
                handler() {
                    const vm = this;
                    vm.getMap().then(map => {
                        vm.curClickFeature = null;
                        vm.selectFeature = null;
                        vm.curMoveFeature = null;
                        vm.moveFeature = null;
                        vm.update(map);
                    })
                },
                deep: true
            },
            zIndex(zindex) {
                if (this.layer && this.layer.getZIndex() !== zindex) {
                    this.layer.setZIndex(zindex);
                }
            },
            layerStyle: {
                handler() {
                    if (this.layerStyle) {
                        const style = transformStyle(this.layerStyle);
                        this.layer.setStyle(style);
                    }
                },
                deep: true
            },
            selectFeatureId: {
                handler(nval) {
                    const vm = this;
                    if (!nval) {
                        vm.selectFeature = null;
                        return false;
                    }
                    vm.getMap().then((map)=>{
                        if(!vm.source) {
                            return false;
                        }
                        vm.selectFeature = vm.getSelectFeature(map, nval, this.storeObject[nval]);
                    })
                }
            },
            selectFeature(nval) {
                //双向数据绑定
                // 应用场景：点击列表，地图相应矢量点击弹框显示；反之，点击矢量，列表对应数据选中
                if (!nval) {
                    this.$emit('update:selectFeatureId', "");
                } else {
                    this.$emit('update:selectFeatureId', nval.featureInfo.data.id);
                }
            }
        },
        mounted() {
            this.init();
        },
        methods: {
            init() {
                this.initData();
                this.getMap().then((map) => {
                    this.map = map;
                    this.createLayer(map, 'mulPathLayer');

                    this.storeObject = {};   //以id为键值，存储数据
                    this.update(map);

                    this.handleEvent(map);
                    this.fitView(map);  // 视图范围自适应

                    if(this.selectFeatureId) {
                        this.selectFeature = this.getSelectFeature(map, this.selectFeatureId, this.storeObject[this.selectFeatureId]);
                    }
                })
            },
            initData() {
                this.map = null;
                this.layer = null;
                this.source = null;
            },
            isRepeatId(grids) {
                let arr = [];
                for (let value of grids) {
                    if (!value.id) {
                        console.error("id缺失：" + JSON.stringify(value));
                        return true;
                    }
                    if (arr.indexOf(value.id) != -1) {
                        let result = grids.filter(item => item.id == value.id);
                        console.error("id重复：" + JSON.stringify(result));
                        return true;
                    }
                    arr.push(value.id);
                }
                return false;
            },
            /**
             *  @description: 通过经纬度和距离，求当前地图坐标系下的单位长度
             *  @param viewProjection 当前地图坐标系
             *  @param distance 距离（米）
             *  @param center 中心点经纬度
             *  @return
             *  @author: xiarx
             *  @date 2020/10/10 18:05
             */
            getRadius(viewProjection, distance, center) {
                if(this.projection==='pixel') {
                    return distance;
                }
                const coords = coordinateTransform(center, this.projection, 'EPSG:4326');
                return calcRadiusAccurate(coords, distance, viewProjection);
            },
            addFeature(featureData, viewProjection) {
                const vm = this;
                let data = Object.assign({},featureData);
                data.projection = vm.projection;
                if (featureData.radius) {   //Circle或者Sector
                    if (vm.projection != "pixel") {
                        data.coords = coordinateTransform(data.coords, vm.projection, viewProjection);
                        data.radius = vm.getRadius(viewProjection, data.radius, featureData.coords);
                        data.projection = viewProjection;
                    }
                }
                let feature = createFeature(data, viewProjection);
                feature.setId(featureData.id);
                if (featureData.style) {
                    feature.setStyle(transformStyle(featureData.style));
                }
                feature.set("featureInfo", {
                    type: "mulPath",
                    data: featureData
                });
                feature.set("mulPathInfo", featureData);

                this.storeObject[featureData.id] = featureData;
                return feature;
            },
            updateFeature(featureData, viewProjection) {
                let f = this.source.getFeatureById(featureData.id);
                if (f) {
                    let geo = f.getGeometry().clone();
                    if (featureData.radius) {   //Circle或者Sector
                        let center = coordinateTransform(featureData.coords, this.projection, viewProjection);
                        let radius = this.getRadius(viewProjection, featureData.radius, featureData.coords);
                        geo.setCenter(center);
                        geo.setRadius(radius);
                    }else {
                        geo.setCoordinates(featureData.coords);
                        if (this.projection != "pixel") {
                            geo = geo.transform(this.projection, viewProjection);
                        }
                    }
                    f.setGeometry(geo);

                    if (featureData.style) {
                        f.setStyle(transformStyle(featureData.style));
                    } else {
                        f.setStyle(null);
                    }

                    f.set("featureInfo", {
                        type: "mulPath",
                        data: featureData
                    });
                    f.set("mulPathInfo", featureData);
                    this.storeObject[featureData.id] = featureData;
                }
            },
            deleteFeature(id) {
                let f = this.source.getFeatureById(id);
                if (f) {
                    this.source.removeFeature(f);
                    delete this.storeObject[id];
                }
            },
            update(map) {
                const vm = this;
                const viewProjection = map.getView().getProjection().getCode();

                //每个feature必须有唯一的id
                if (vm.isRepeatId(vm.grids)) {
                    console.error("多矢量组件中每个矢量必须有唯一的id值");
                    return false;
                }

                let nVal = vm.grids;
                let features = new Array();
                const idSet = new Array();
                nVal.forEach(function (featureData) {
                    if (vm.storeObject[featureData.id]) {
                        vm.updateFeature(featureData, viewProjection);
                    } else {
                        let feature = vm.addFeature(featureData, viewProjection);
                        if (feature) {
                            features.push(feature);
                        }
                    }
                    idSet.push(featureData.id+'');  // id为number类型时，强转成string
                });
                vm.source.addFeatures(features);

                for (let key in vm.storeObject) {
                    if (idSet.indexOf(key) == -1) {
                        vm.deleteFeature(key);
                    }
                }

                vm.$emit("load-finished", {
                    source: vm.source
                })
            },

            //feature 中心点位获取
            getCenter(map, feature) {
                const vm = this;
                let centerPoint;
                let geo = feature.getGeometry();
                if (vm.projection != 'pixel') {
                    geo = geo.clone().transform(map.getView().getProjection(), vm.projection);
                }
                if (geo instanceof Point) {
                    centerPoint = geo.getCoordinates();
                } else if (geo instanceof LineString) {
                    centerPoint = geo.getCoordinateAt(0.5);
                } else if (geo instanceof Circle) {
                    centerPoint = geo.getCenter();
                } else if (geo instanceof Polygon) {
                    let coords = geo.getInteriorPoint().getCoordinates();
                    centerPoint = [coords[0], coords[1]];
                } else {
                    if (geo.getCenter) {
                        centerPoint = geo.getCenter();
                    } else {
                        let coords = geo.getInteriorPoint().getCoordinates();
                        centerPoint = [coords[0], coords[1]];
                    }
                }
                return centerPoint;
            },
            getSelectFeature(map, id, featureData) {
                const vm = this;
                let feature = this.source.getFeatureById(id);
                if (feature) {
                    //恢复前次标记的feature的样式
                    if (vm.curClickFeature && vm.curClickFeature !== feature) {
                        vm.curClickFeature.setStyle(vm.curClickStyle);
                        vm.curClickFeature = null;
                        vm.selectFeature = null;
                    }
                    const clickStyle = vm.clickStyle||feature.get('featureInfo').data.clickStyle;

                    if (clickStyle && vm.curClickFeature !== feature) {
                        let isNull = false;   //样式函数返回的是否为空
                        if(transformStyle(clickStyle) instanceof Function) {
                            let fn = transformStyle(clickStyle);
                            if(!fn(feature)){
                                isNull = true;
                            }
                        }
                        if(!isNull) {
                            vm.curClickStyle = vm.curMoveNormalStyle;
                            feature.setStyle(transformStyle(clickStyle));
                            vm.curClickFeature = feature;
                        }
                    }
                    return {
                        coords: this.getCenter(map, feature),
                        projection: this.projection,
                        featureInfo: {
                            type: "mulPath",
                            data: featureData
                        },
                        mulPathInfo: featureData
                    };
                }
                return null;
            }
        }
    }
</script>
