<script>
    import {Vector as VectorSource} from "ol/source";
    import * as OlFormat from "ol/format";
    import {createObjJson, createUrlJson} from '../../utils/vectorLayer'
    import {transformStyle} from "../../utils/helpers";

    export default {
        name: "olVectorSource",
        render(h) {
            return h('div', {
                    class: 'ol-vector-source',
                    style: {
                        display: 'none !important'
                    }
                },
                this.$slots.default
            );
        },
        inject: ['getMap', 'getLayer'],
        props: {
            attributions: String | Array | Function,
            format: String,  // EsriJSON, GeoJSON, KML等
            formatOptions: Object,
            loader: Function,
            overlaps: {type: Boolean, default: true},
            strategy: Function,
            url: String | Function,
            local: {type: Boolean, default: false},
            jsonObject: Object,   // 直接传json对象，例如：{geojson: { object: {}, projection: "EPSG:3857"}}
            useSpatialIndex: {type: Boolean, default: true},
            wrapX: {type: Boolean, default: true},
            featureStyle: [Object, Array, Function] // 为feature单独设置样式
        },
        data() {
            return {
                source: null,
                olFormat: null,
                viewProjection: null
            }
        },
        watch: {
            attributions(attributions) {
                if (this.source) {
                    this.source.setAttributions(attributions);
                }
            },
            url() {
                if (this.source) {
                    this.updateUrl();
                }
            }
        },
        mounted() {
            this.init();
        },
        methods: {
            createSource() {
                const options = {
                    attributions: this.attributions,
                    overlaps: this.overlaps,
                    strategy: this.strategy,
                    useSpatialIndex: this.useSpatialIndex,
                    wrapX: this.wrapX
                }
                if (this.format) {
                    this.olFormat = new OlFormat[this.format](this.formatOptions || null);
                    options.format = this.olFormat;
                }
                if (this.url) {
                    if (this.local) {
                        options.url = this.url;
                    }
                } else if (this.loader) {
                    options.loader = this.loader;
                }
                let oSource = new VectorSource(options);
                return oSource;
            },
            setStyle(features) {
                if (this.featureStyle) {
                    features.forEach((f) => {
                        f.setStyle(transformStyle(this.featureStyle))
                    })
                }
            },
            async updateUrl() {
                if (this.local) {
                    this.source.setUrl(this.url);
                    this.source.once('featuresloadend', (e) => {
                        const {features} = e;
                        this.setStyle(features);
                        this.$emit('loadend', {
                            source: this.source,
                            features
                        });
                    })
                    this.source.once('featuresloaderror', (e) => {
                        this.$emit('loaderror', {
                            source: this.source
                        });
                    })
                } else {
                    try {
                        const features = await createUrlJson(this.olFormat, this.url, this.viewProjection);
                        this.setStyle(features);
                        this.source.addFeatures(features);
                        this.$emit('loadend', {
                            source: this.source,
                            features
                        });
                    }catch (e) {
                        this.$emit('loaderror', {
                            source: this.source,
                            msg: e
                        });
                    }
                }
            },
            async addFeatures() {  // 远程获取矢量数据或者直接解析矢量数据
                if (this.url) {
                    this.updateUrl();
                } else if (this.jsonObject) {
                    const jsonData = this.jsonObject[this.format.toLowerCase()];
                    const features = createObjJson(this.olFormat, jsonData, this.viewProjection);
                    this.source.addFeatures(features);
                    this.$emit('loadend', {
                        source: this.source,
                        features
                    });
                } else if (!this.loader) {
                    console.error('[Vue - Openlayers] - You need a ' + this.format +
                        ' property to add a ' + this.format + ' layer.');
                }
            },
            async init() {
                const map = await this.getMap();
                this.viewProjection = map.getView().getProjection();
                const layer = await this.getLayer();
                this.source = this.createSource();
                layer.setSource(this.source);
                this.addFeatures();
            },
        },
        beforeDestroy() {
            const vm = this;
            vm.source.clear();
            vm.source = null;
        }
    }
</script>
