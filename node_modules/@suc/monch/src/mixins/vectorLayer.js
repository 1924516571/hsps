import {createVectorLayer} from "../utils/vectorLayer";
import {coordinateTransform, transformStyle} from "..";

export default {
    props: {
        className: {
            type: String,
            default: 'ol-layer'
        },
        opacity: {
            type: Number,
            default: 1
        },
        visible: {
            type: Boolean,
            default: true
        },
        extent: {
            type: Array,
            validator: value => value.length === 4
        },
        zIndex: {
            type: Number,
            default: 0
        },
        minResolution: Number,
        maxResolution: Number,
        minZoom: Number,
        maxZoom: Number,
        renderOrder: Function,
        renderBuffer: {
            type: Number,
            default: 100
        },
        declutter: {
            type: Boolean,
            default: false
        },
        updateWhileAnimating: {
            type: Boolean,
            default: false
        },
        updateWhileInteracting: {
            type: Boolean,
            default: false
        },
        /*
        ** Render mode for vector layers:
        **   1, 'image': Vector layers are rendered as images. Great performance,
        **         but point symbols and texts are always rotated with the view and pixels are scaled during zoom animations.
        **   2, 'vector': Vector layers are rendered as vectors. Most accurate rendering even during animations,
        **        but slower performance.
        */
        renderMode: {
            type: String,
            default: 'vector'
        },
        layerId: [String, Number],
        layerStyle: [Object, Array, Function],
        isFit: {       //是否在初始化时设置图层自适应屏幕
            type: Boolean,
            default: false
        },
        fitPadding: {  // 仅在 isFit 为 true 时起作用
            type: Array,
            validator: value => value.length === 4,
            default: () => [60, 30, 10, 30]
        },
    },
    data() {
        return {
            layer: null,
            source: null
        }
    },
    watch: {
        opacity(opacity) {
            if (this.layer && this.layer.getOpacity() !== opacity) {
                this.layer.setOpacity(opacity);
            }
        },
        extent(extent) {
            if (this.layer && this.layer.getExtent() !== extent) {
                this.layer.setExtent(extent);
            }
        },
        minResolution(minResolution) {
            if (this.layer && this.layer.getMinResolution() !== minResolution) {
                this.layer.setMinResolution(minResolution);
            }
        },
        maxResolution(maxResolution) {
            if (this.layer && this.layer.getMaxResolution() !== maxResolution) {
                this.layer.setMaxResolution(maxResolution);
            }
        },
        minZoom(minZoom) {
            if (this.layer && this.layer.getMinZoom() !== minZoom) {
                this.layer.setMinZoom(minZoom);
            }
        },
        maxZoom(maxZoom) {
            if (this.layer && this.layer.getMaxZoom() !== maxZoom) {
                this.layer.setMaxZoom(maxZoom);
            }
        },
        zIndex(zIndex) {
            if (this.layer && this.layer.getZIndex() !== zIndex) {
                this.layer.setZIndex(zIndex);
            }
        },
        visible(visible) {
            if (this.layer && this.layer.getVisible() !== visible) {
                this.layer.setVisible(visible);
            }
        },
    },
    methods: {
        createLayer(map, layerClass, clusteringDistance) {
            let options = {
                className: this.className,
                opacity: this.opacity,
                visible: this.visible,
                extent: this.extent,
                zIndex: this.zIndex,
                minResolution: this.minResolution,
                maxResolution: this.maxResolution,
                minZoom: this.minZoom,
                maxZoom: this.maxZoom,
                renderOrder: this.renderOrder,
                renderBuffer: this.renderBuffer,
                declutter: this.declutter,
                updateWhileAnimating: this.updateWhileAnimating,
                updateWhileInteracting: this.updateWhileInteracting,
            }

            // 聚集图层
            if (typeof clusteringDistance !== 'undefined') {
                options.clustering = true;
                options.clusteringDistance = clusteringDistance;
            }
            const {layer, source} = createVectorLayer(options, this.renderMode);
            this.layer = layer;
            this.source = source;
            this.layer.set(layerClass, true);
            if (this.layerId) {
                this.layer.set("id", this.layerId);
            }
            map.addLayer(this.layer);

            if (this.layerStyle) {
                const style = transformStyle(this.layerStyle);
                this.layer.setStyle(style);
            }
        },
        fitView(map, clustering) {
            if (this.isFit) {
                let view = map.getView();
                const source = clustering ? this.source.getSource() : this.source;
                view.fit(source.getExtent(), {
                    padding: this.fitPadding,
                    callback: () => {
                        this.$emit('fit', {
                            center: coordinateTransform(view.getCenter(), view.getProjection().getCode(), this.projection),
                            zoom: view.getZoom()
                        })
                    }
                });
            }
        }
    }
}
