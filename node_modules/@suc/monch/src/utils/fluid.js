import {containsCoordinate} from "ol/extent";
import { fromLonLat, transformExtent} from 'ol/proj';
import {Polygon} from 'ol/geom';
import {
    coordinateTransform
} from './helpers';

export class Fluid{
    constructor(options={}) {
        this.MAX_PARTICLE_AGE=options.age || 100;//粒子最大运动次数
        this.FRAME_RATE=options.rate || 20;//重绘帧数
        this.PARTICLE_MULTIPLIER=options.multi || 3;
        this.SPEED_WEIGHT=options.weight || 1;
        this.colorful=!!options.colorful;
        this.colormap=options.colorMap || function(v){
            let color='rgba(148,0,60,.8)';
            if(v<0.3){
                color = 'rgba('+parseInt(84+150*v)+','+parseInt(74+1280/3*v)+','+parseInt(152+40/3*v)+',.8)';
            }else if(v<0.6){
                color = 'rgba('+parseInt(3+420*v)+','+parseInt(151+170*v)+','+parseInt(126+100*v)+',.8)';
            }else if(v<0.9){
                color = 'rgba('+parseInt(275-100/3*v)+','+parseInt(499-410*v)+','+parseInt(402-360*v)+',.8)';
            }else if(v<1.2){
                color = 'rgba('+parseInt(536-970/3*v)+','+parseInt(520-1300/3*v)+','+parseInt(132-60*v)+',.8)';
            }
            return color
        };
        this.canvas=options.canvas;
        this.width=this.canvas.width;
        this.height=this.canvas.height;
        this.ctx=this.canvas.getContext('2d');
        this.ctx.lineWidth = options.lineWidth || 0.8;
        this.ctx.fillStyle = options.fillStyle || 'rgba(0,0,0,.97)';
        this.datalength=options.data;

        window.requestAnimationFrame = (function () {
            return window.requestAnimationFrame ||
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                window.oRequestAnimationFrame ||
                window.msRequestAnimationFrame ||
                function (callback) {
                    window.setTimeout(callback, 1000 / 20);
                };
        })();
    }

    buildBounds(extent, callback) {
        let upperLeft = extent[0];
        let lowerRight = extent[1];
        let bounds = {
            x: upperLeft[0],
            y: upperLeft[1],
            xmax: lowerRight[0],
            ymax: lowerRight[1],
            width: lowerRight[0] - upperLeft[0],
            height: lowerRight[1] - upperLeft[1]
        };
        callback(bounds);
    }

    createField(columns, bounds, callback) {
        function vector(x, y) {
            let column = columns[Math.floor(x)];
            return column && column[Math.floor(y)];
        }

        vector.release = ()=>{
            columns = [];
        };

        vector.randomize = (o)=>{
            let x = Math.floor(Math.floor(Math.random() * bounds.width) + bounds.x);
            let y = Math.floor(Math.floor(Math.random() * bounds.height) + bounds.y);
            o.x = x;
            o.y = y;
            return o;
        };
        callback(bounds, vector);
    };

    interpolateGrid(bounds, stationPoints, callback) {
        let {datalength} = this;
        let columns = [];

        function interpolatef(x, y) {
            let sites=[];
            let speedx = 0,
                speedy = 0,
                speedz = 0,
                wind = {
                    speedx:0,
                    speedy:0
                };
            sites=clipsite(x, y);
            sites.forEach(function (s) {
                let sl=((y - s.y) * (y - s.y) + (x - s.x) * (x - s.x));
                speedx += s.speedx * 1.0 / sl;
                speedy += s.speedy * 1.0 / sl;
                speedz += 1.0 / sl;
            });
            if (speedz != 0) {
                wind.speedx = speedx / speedz;
                wind.speedy = speedy / speedz;
            }
            return wind;
        }

        function clipsite(x, y) {
            if(x>datalength.maxx || y>datalength.maxy){
                return []
            }
            let sites=[];
            let i=Math.floor((x-datalength.minx)/datalength.xs);
            let j=Math.floor((y-datalength.miny)/datalength.ys);
            if(stationPoints['a'+i] && stationPoints['a'+i]['a'+j]){
                sites=stationPoints['a'+i]['a'+j]
            }
            return sites;
        }

        function interpolatefast() {
            let y = bounds.y;
            let x = bounds.x;
            let column = [];
            for (x = bounds.x; x < bounds.xmax; x += 2) {
                column = [];
                for (y = bounds.y; y < bounds.ymax; y += 2) {
                    column[y + 1] = column[y] = interpolatef(x, y);
                }
                columns[x + 1] = columns[x] = column;
            }
        }
        let that=this;
        (function batchInterpolate() {
            let start = Date.now();
            interpolatefast();
            that.createField(columns, bounds, callback);
        })();
    };

    animate(bounds, vector) {
        let {MAX_PARTICLE_AGE,FRAME_RATE,PARTICLE_MULTIPLIER,SPEED_WEIGHT,colorful,colormap,width,height,ctx,timer} = this;
        let particleCount = Math.round(bounds.width * PARTICLE_MULTIPLIER);
        let particles = [];
        for (let i = 0; i < particleCount; i++) {
            particles.push(vector.randomize({
                age: Math.floor(Math.random() * MAX_PARTICLE_AGE)
            }));
        }

        function evolve() {
            particles.forEach((particle, i) => {
                if (particle.age > MAX_PARTICLE_AGE) {
                    particle = vector.randomize({
                        age: 0
                    });
                    particles.splice(i, 1, particle);
                }
                let x = particle.x;
                let y = particle.y;
                let v = vector(x, y);
                if (v) {
                    particle.v=Math.sqrt(v.speedx*v.speedx+v.speedy*v.speedy);
                    let xe = x + v.speedx*SPEED_WEIGHT;
                    let ye = y - v.speedy*SPEED_WEIGHT;
                    let nextPoint = vector(xe, ye);
                    if (nextPoint) {
                        particle.xe = xe;
                        particle.ye = ye;
                    } else {
                        let newParticle = vector.randomize({
                            age: Math.floor(Math.random() * MAX_PARTICLE_AGE)
                        });
                        particles.splice(i, 1, newParticle);
                    }
                } else {
                    particle.age = MAX_PARTICLE_AGE;
                }
                particle.age += 1;
            });
        }

        function render() {
            let prev = ctx.globalCompositeOperation;
            ctx.globalCompositeOperation = "destination-in";
            ctx.fillRect(0, 0, width, height);
            ctx.globalCompositeOperation = prev;

            if(colorful){
                particles.forEach(function (particle, i) {
                    ctx.strokeStyle=colormap(particle.v);
                    ctx.beginPath();
                    ctx.moveTo(particle.x, particle.y);
                    ctx.lineTo(particle.xe, particle.ye);
                    ctx.stroke();
                    ctx.closePath();
                    particle.x = particle.xe;
                    particle.y = particle.ye;
                });
            }else{
                ctx.beginPath();
                // ctx.strokeStyle = 'rgba(23,139,231,.8)';
                particles.forEach((particle, i) => {
                    ctx.moveTo(particle.x, particle.y);
                    ctx.lineTo(particle.xe, particle.ye);
                    particle.x = particle.xe;
                    particle.y = particle.ye;
                });
                ctx.stroke();
            }
        }
        let that=this;
        (function frame() {
            try {
                timer = that.timer = setTimeout(() => {
                    requestAnimationFrame(frame);
                    evolve();
                    render();
                }, 1000 / FRAME_RATE);
            } catch (e) {
                console.error(e);
            }
        })();
    };

    start(extent, stationPoints) {
        let that=this;
        that.stop();
        that.buildBounds(extent, (bounds) => {
            that.interpolateGrid(bounds, stationPoints, (bounds, vector)=> {
                that.vector = vector;
                that.animate(bounds, vector);
            });
        });
    };

    stop() {
        let {width,ctx,vector,height,timer} = this;
        ctx.clearRect(0, 0, width, height);
        if (vector) vector.release();
        if (timer) clearTimeout(timer);
    };

    change(options) {
        let {ctx} = this;
        ctx.lineWidth = options.size;
        ctx.strokeStyle = options.color;
    }
}

export class MatrixFluid{
    constructor(options={}) {
        this.MAX_PARTICLE_AGE=options.age || 100;//粒子最大运动次数
        this.FRAME_RATE=options.rate || 20;//重绘帧数
        this.PARTICLE_MULTIPLIER=options.multi || 1;
        this.SPEED_WEIGHT=options.weight || 0.5;
        this.colorful=!!options.colorful;
        this.colormap=options.colorMap || function(v){
            let color='rgba(148,0,60,.8)';
            if(v<0.3){
                color = 'rgba('+parseInt(84+150*v)+','+parseInt(74+1280/3*v)+','+parseInt(152+40/3*v)+',.8)';
            }else if(v<0.6){
                color = 'rgba('+parseInt(3+420*v)+','+parseInt(151+170*v)+','+parseInt(126+100*v)+',.8)';
            }else if(v<0.9){
                color = 'rgba('+parseInt(275-100/3*v)+','+parseInt(499-410*v)+','+parseInt(402-360*v)+',.8)';
            }else if(v<1.2){
                color = 'rgba('+parseInt(536-970/3*v)+','+parseInt(520-1300/3*v)+','+parseInt(132-60*v)+',.8)';
            }
            return color
        };
        this.canvas=options.canvas;
        this.width=this.canvas.width;
        this.height=this.canvas.height;
        this.ctx=this.canvas.getContext('2d');
        this.ctx.lineWidth = options.lineWidth || 0.8;
        this.ctx.fillStyle = options.fillStyle || 'rgba(0,0,0,.97)';
        this.datalength=options.data;

        window.requestAnimationFrame = (function () {
            return window.requestAnimationFrame ||
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                window.oRequestAnimationFrame ||
                window.msRequestAnimationFrame ||
                function (callback) {
                    window.setTimeout(callback, 1000 / 20);
                };
        })();
    }

    buildBounds(extent, callback) {
        let upperLeft = extent[0];
        let lowerRight = extent[1];
        let bounds = {
            x: upperLeft[0],
            y: upperLeft[1],
            xmax: lowerRight[0],
            ymax: lowerRight[1],
            width: lowerRight[0] - upperLeft[0],
            height: lowerRight[1] - upperLeft[1]
        };
        callback(bounds);
    }

    createField(columns, bounds, callback) {
        function vector(x, y) {
            let column = columns[Math.floor(x)];
            return column && column[Math.floor(y)];
        }

        vector.release = ()=>{
            columns = [];
        };

        vector.randomize = (o)=>{
            let x = Math.floor(Math.floor(Math.random() * bounds.width) + bounds.x);
            let y = Math.floor(Math.floor(Math.random() * bounds.height) + bounds.y);
            o.x = x;
            o.y = y;
            return o;
        };
        callback(bounds, vector);
    };

    interpolateGrid(bounds, stationPoints, callback) {
        let {datalength} = this;
        let columns = [];

        function interpolatef(x, y,dataobj) {
            let sites=[];
            let speedx0 = 0,
                speedx1 = 0,
                speedy0 = 0,
                speedy1 = 0,
                wind = {
                    speedx:0,
                    speedy:0
                };
            if(x<stationPoints[0].x || y<stationPoints[0].y || x>stationPoints[dataobj.indexmax].x || y>stationPoints[dataobj.indexmax].y){
                return wind;
            }else{
                sites=clipsite(x, y,dataobj)
            }
            sites.forEach((s) => {
                let sl=((y - s.y) * (y - s.y) + (x - s.x) * (x - s.x))
                speedx0 += s.speedx * 1.0 / sl;
                speedx1 += 1.0 / sl;

                speedy0 += s.speedy * 1.0 / sl;
                speedy1 += 1.0 / sl;
            });
            if (speedx1 != 0) {
                wind.speedx = speedx0 / speedx1;
            }
            if (speedy1 != 0) {
                wind.speedy = speedy0 / speedy1;
            }
            return wind;
        }
        function clipsite(x, y,dataobj) {
            let sites=[];
            let ix=0;
            let iy=0;
            ix=Math.round((x-stationPoints[0].x)/dataobj.xl*(datalength.lonlength-1));
            iy=Math.round((y-stationPoints[0].y)/dataobj.yl*(datalength.latlength-1));
            let areanum={
                xin:null,
                yin:null,
                xax:null,
                yax:null
            };
            if(ix<10){
                areanum.xin=0;
                areanum.xax=ix+9;
            }else if(ix>datalength.lonlength-11){
                areanum.xin=ix-9;
                areanum.xax=datalength.lonlength-1;
            }else{
                areanum.xin=ix-9;
                areanum.xax=ix+9;
            }
            if(iy<10){
                areanum.yin=0;
                areanum.yax=iy+9;
            }else if(iy>datalength.latlength-11){
                areanum.yin=iy-9;
                areanum.yax=datalength.latlength-1;
            }else{
                areanum.yin=iy-9;
                areanum.yax=iy+9;
            }
            for(let i=areanum.xin;i<=areanum.xax;i++){
                for(let j=areanum.yin;j<=areanum.yax;j++){
                    sites.push(stationPoints[i+datalength.lonlength*j]);
                }
            }
            return sites;
        }

        function interpolatefast() {
            let dataobj={}
            dataobj.indexmax=stationPoints.length-1;
            dataobj.xl=stationPoints[dataobj.indexmax].x-stationPoints[0].x;
            dataobj.yl=stationPoints[dataobj.indexmax].y-stationPoints[0].y;

            let y = bounds.y;
            let x = bounds.x;
            let column = [];
            for (x = bounds.x; x < bounds.xmax; x += 2) {
                column = [];
                for (y = bounds.y; y < bounds.ymax; y += 2) {
                    column[y + 1] = column[y] = interpolatef(x, y,dataobj);
                }
                columns[x + 1] = columns[x] = column;
            }
            // console.log(columns)
        }
        let that=this;
        (function batchInterpolate() {
            let start = Date.now();
            interpolatefast();
            that.createField(columns, bounds, callback);
        })();
    };

    animate(bounds, vector) {
        let {MAX_PARTICLE_AGE,FRAME_RATE,PARTICLE_MULTIPLIER,SPEED_WEIGHT,colorful,colormap,width,height,ctx,timer} = this;
        let particleCount = Math.round(bounds.width * PARTICLE_MULTIPLIER);
        let particles = [];
        for (let i = 0; i < particleCount; i++) {
            particles.push(vector.randomize({
                age: Math.floor(Math.random() * MAX_PARTICLE_AGE)
            }));
        }

        function evolve() {
            particles.forEach((particle, i) => {
                if (particle.age > MAX_PARTICLE_AGE) {
                    particle = vector.randomize({
                        age: 0
                    });
                    particles.splice(i, 1, particle);
                }
                let x = particle.x;
                let y = particle.y;
                let v = vector(x, y);
                if (v) {
                    particle.v=Math.sqrt(v.speedx*v.speedx+v.speedy*v.speedy);
                    let xe = x + v.speedx*SPEED_WEIGHT;
                    let ye = y - v.speedy*SPEED_WEIGHT;
                    let nextPoint = vector(xe, ye);
                    if (nextPoint) {
                        particle.xe = xe;
                        particle.ye = ye;
                    } else {
                        let newParticle = vector.randomize({
                            age: Math.floor(Math.random() * MAX_PARTICLE_AGE)
                        });
                        particles.splice(i, 1, newParticle);
                    }
                } else {
                    particle.age = MAX_PARTICLE_AGE;
                }
                particle.age += 1;
            });
        }

        function render() {
            let prev = ctx.globalCompositeOperation;
            ctx.globalCompositeOperation = "destination-in";
            ctx.fillRect(0, 0, width, height);
            ctx.globalCompositeOperation = prev;

            if(colorful){
                particles.forEach(function (particle, i) {
                    ctx.strokeStyle=colormap(particle.v);
                    ctx.beginPath();
                    ctx.moveTo(particle.x, particle.y);
                    ctx.lineTo(particle.xe, particle.ye);
                    ctx.stroke();
                    ctx.closePath();
                    particle.x = particle.xe;
                    particle.y = particle.ye;
                });
            }else{
                ctx.beginPath();
                // ctx.strokeStyle = 'rgba(23,139,231,.8)';
                particles.forEach((particle, i) => {
                    ctx.moveTo(particle.x, particle.y);
                    ctx.lineTo(particle.xe, particle.ye);
                    particle.x = particle.xe;
                    particle.y = particle.ye;
                });
                ctx.stroke();
            }
        }
        let that=this;
        (function frame() {
            try {
                timer = that.timer = setTimeout(() => {
                    requestAnimationFrame(frame);
                    evolve();
                    render();
                }, 1000 / FRAME_RATE);
            } catch (e) {
                console.error(e);
            }
        })();
    };

    start(extent, stationPoints) {
        let that=this;
        that.stop();
        that.buildBounds(extent, (bounds) => {
            that.interpolateGrid(bounds, stationPoints, (bounds, vector)=> {
                that.vector = vector;
                that.animate(bounds, vector);
            });
        });
    };

    stop() {
        let {width,ctx,vector,height,timer} = this;
        ctx.clearRect(0, 0, width, height);
        if (vector) vector.release();
        if (timer) clearTimeout(timer);
    };

    change(options) {
        let {ctx} = this;
        ctx.lineWidth = options.size;
        ctx.strokeStyle = options.color;
    }
}

export class ShortFluid{
    constructor(options={}) {
        this.MAX_PARTICLE_AGE=options.age || 20;//粒子最大运动次数
        this.FRAME_RATE=options.rate || 15;//重绘帧数
        this.PARTICLE_MULTIPLIER=options.multi || 1;
        this.color=options.color;
        this.canvas=options.canvas;
        this.width=this.canvas.width;
        this.height=this.canvas.height;
        this.ctx=this.canvas.getContext('2d');
        this.ctx.lineWidth = options.lineWidth || 6.8;
        this.ctx.fillStyle = options.fillStyle || 'rgba(0,0,0,.8)';
        this.jizhi=options.jizhi;
        this.num=options.num;
        this.map=options.map;
        this.edge=new Polygon(options.edge);

        window.requestAnimationFrame = (function () {
            return window.requestAnimationFrame ||
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                window.oRequestAnimationFrame ||
                window.msRequestAnimationFrame ||
                function (callback) {
                    window.setTimeout(callback, 1000 / 20);
                };
        })();
    }

    buildBounds(extent, callback) {
        let upperLeft = extent[0];
        let lowerRight = extent[1];
        let bounds = {
            x: upperLeft[0],
            y: upperLeft[1],
            xmax: lowerRight[0],
            ymax: lowerRight[1],
            width: lowerRight[0] - upperLeft[0],
            height: lowerRight[1] - upperLeft[1]
        };
        callback(bounds);
    }

    createField(columns, bounds, callback) {
        function vector(x, y) {
            let column = columns[Math.floor(x)];
            return column && column[Math.floor(y)];
        }

        vector.release = ()=>{
            columns = [];
        };

        vector.randomize = (o)=>{
            let x = Math.floor(Math.floor(Math.random() * bounds.width) + bounds.x);
            let y = Math.floor(Math.floor(Math.random() * bounds.height) + bounds.y);
            o.x = x;
            o.y = y;
            return o;
        };
        callback(bounds, vector);
    };

    interpolateGrid(bounds, stationPoints, callback) {
        let {jizhi,num,map,edge} = this;
        let columns = [];
        let x = bounds.x;
        let cubea=10;
        let cubec=1;
        let cubeb=(stationPoints[jizhi.maxx].x-stationPoints[jizhi.minx].x)*(stationPoints[jizhi.maxy].y-stationPoints[jizhi.miny].y)/num*36*cubec;
        let cubed=Math.sqrt(cubeb);
        function interpolateColumn(x) {
            let column = [];
            for (let y = bounds.y; y < bounds.ymax; y += cubea*2) {
                let wind = interpolate(x+cubea, y+cubea);
                for(let z=y;z<y+cubea*2;z++){
                    column[z]=wind
                }
            }
            for(let z=x;z<x+cubea*2;z++){
                columns[z]=column
            }
        }

        function calcgridv(x, y) {
            let sites = [];
            if(y>stationPoints[stationPoints.length-1].y || y<stationPoints[0].y){
                return sites;
            }
            let i,j,k=1;
            while(k<stationPoints.length && !(i && j)){
                if(typeof i=='number'){
                    if(stationPoints[k].y>y+cubed){
                        j=k
                    }
                }else{
                    if(stationPoints[k].y>y-cubed){
                        i=k-1
                    }
                }
                k++;
            }
            if(typeof i=='number'){
                sites = stationPoints.slice(i,j);
            }
            return sites;
        }

        function interpolate(x, y) {
            let angle0 = 0,
                angle1 = 0,
                anum = 0,
                wind = {};
            let point=coordinateTransform(map.getCoordinateFromPixel([x,y]), map.getView().getProjection().getCode(), "EPSG:4326");

            if(edge.intersectsCoordinate(point)){
                let sites=calcgridv(x, y)
                sites.forEach(function (s) {
                    let al=((y - s.y) * (y - s.y) + (x - s.x) * (x - s.x))
                    if(al>0 && al<=cubeb){
                        angle0 += s.angle * 1.0 / al;
                        angle1 += 1.0 / al;
                        anum++;
                        if (angle1 != 0) {
                            wind.angle = angle0 / angle1;
                        }
                        if (typeof angle0 == 'number') {
                            wind.speed = 0.5;
                        }
                    }
                });
            }
            if(anum<cubec || !wind.speed){
                wind = null;
            }
            return wind;
        }

        let that=this;
        (function batchInterpolate() {
            let start = Date.now();
            while (x < bounds.xmax) {
                interpolateColumn(x);
                x += cubea*2;
            }
            that.createField(columns, bounds, callback);
        })();
    };

    animate(bounds, vector) {
        let {MAX_PARTICLE_AGE,FRAME_RATE,PARTICLE_MULTIPLIER,color,width,height,ctx,timer} = this;
        let particleCount = Math.round(bounds.width * PARTICLE_MULTIPLIER);
        let particles = [];
        for (let i = 0; i < particleCount; i++) {
            particles.push(vector.randomize({
                age: Math.floor(Math.random() * MAX_PARTICLE_AGE)
            }));
        }

        function evolve() {
            particles.forEach((particle, i) => {
                if (particle.age > MAX_PARTICLE_AGE) {
                    particle = vector.randomize({
                        age: 0
                    });
                    particles.splice(i, 1, particle);
                }
                let x = particle.x;
                let y = particle.y;
                let v;
                if(particle.v){
                    v = particle.v;
                }else{
                    v = vector(x, y);
                    particle.v=v;
                }
                if (vector(x, y)) {
                    let xe = x + v.speed * Math.cos(Math.PI / 180 * (90-v.angle));
                    let ye = y - v.speed * Math.sin(Math.PI / 180 * (90-v.angle));
                    let nextPoint = vector(xe, ye);
                    if (nextPoint) {
                        particle.xe = xe;
                        particle.ye = ye;
                    } else {
                        let newParticle = vector.randomize({
                            age: Math.floor(Math.random() * MAX_PARTICLE_AGE)
                        });
                        particles.splice(i, 1, newParticle);
                    }
                } else {
                    particle.age = MAX_PARTICLE_AGE;
                }
                particle.age += 1;
            });
        }

        function render() {
            let prev = ctx.globalCompositeOperation;
            ctx.globalCompositeOperation = "destination-in";
            ctx.fillRect(0, 0, width, height);
            ctx.globalCompositeOperation = prev;

            if(color){
                ctx.strokeStyle = color;
            }
            ctx.beginPath();
            particles.forEach((particle, i) => {
                ctx.moveTo(particle.x, particle.y);
                ctx.lineTo(particle.xe, particle.ye);
                particle.x = particle.xe;
                particle.y = particle.ye;
            });
            ctx.stroke();
        }
        let that=this;
        (function frame() {
            try {
                timer = that.timer = setTimeout(() => {
                    requestAnimationFrame(frame);
                    evolve();
                    render();
                }, 1000 / FRAME_RATE);
            } catch (e) {
                console.error(e);
            }
        })();
    };

    start(extent, stationPoints) {
        let that=this;
        that.stop();
        that.buildBounds(extent, (bounds) => {
            that.interpolateGrid(bounds, stationPoints, (bounds, vector)=> {
                that.vector = vector;
                that.animate(bounds, vector);
            });
        });
    };

    stop() {
        let {width,ctx,vector,height,timer} = this;
        ctx.clearRect(0, 0, width, height);
        if (vector) vector.release();
        if (timer) clearTimeout(timer);
    };

    change(options) {
        let {ctx} = this;
        ctx.lineWidth = options.size;
        ctx.strokeStyle = options.color;
    }
}
