import {Cluster, Vector as VectorSource} from "ol/source";
import {bbox} from "ol/loadingstrategy";
import {Vector as VectorLayer, VectorImage} from "ol/layer";
import {isDefined} from "./helpers";
import {get as getProj} from "ol/proj";

export function createVectorLayer(options, renderMode) {
    const layerOptions = {...options};
    let source = new VectorSource({
        strategy: bbox
    });
    if (options.clustering) {
        source = new Cluster({
            source: source,
            distance: options.clusteringDistance
        });
        delete layerOptions.clustering;
        delete layerOptions.clusteringDistance;
    }
    layerOptions.source = source;
    let layer;
    if (renderMode == 'image') {
        layer = new VectorImage(layerOptions);
    } else {
        layer = new VectorLayer(layerOptions);
    }
    return {
        source,
        layer
    }
}

// json
export function createObjJson(olFormat,jsonData, projection) {
    let projectionToUse = projection;
    let dataProjection;
    if (isDefined(jsonData.projection)) {
        dataProjection = getProj(jsonData.projection);
    } else {
        dataProjection = projection;
    }

    const features = olFormat.readFeatures(jsonData.object, {
        featureProjection: projectionToUse.getCode(),
        dataProjection: dataProjection.getCode()
    });
    return features;
}

// 使用script进行跨域请求
function jsonp(url, data) {
    let defer = {
        resolve: null,
        reject: null
    }
    const promise = new Promise((resolve, reject) => {
        defer.resolve = resolve;
        defer.reject = reject;
    });
    let flag = false;//用于标识是否成功返回
    // 回调函数+时间戳
    const cbName = 'callback_' + new Date().getTime() + Math.round(Math.random() * 100);
    // 暴露全局函数给window
    // 判读查询字符串最后一位是否为?或者是&
    let queryString = url.indexOf('?') == -1 ? '?' : '&';
    // 遍历传进来的data实参赋值给查询字符串
    for (let k in data) {
        queryString += k + '=' + data[k] + '&';
    }
    // 查询字符串加上回调函数
    queryString += 'callback=' + cbName;
    // 创建script标签
    let ele = document.createElement('script');
    // 给script标签添加src属性值
    ele.src = url + queryString;
    // 添加到body尾部
    document.body.appendChild(ele);

    function removeEle() {
        let scripts = document.body.getElementsByTagName("script");
        const len = scripts.length;
        for (let i = len - 1; i > -1; i--) {
            if (scripts[i].src.indexOf(cbName) != -1) {
                document.body.removeChild(scripts[i]);
                window[cbName] = undefined;
                try {
                    delete window[cbName];
                } catch (e) {
                } //删除
            }
        }
    }

    window[cbName] = function (data) {
        flag = true;  //成功返回
        defer.resolve(data);
        removeEle();
    };
    window[cbName + "_err"] = function () {
        if (!flag) {   //20s之后还未成功返回 控制台打印失败信息
            defer.reject("跨域script请求失败或者请求超时！");
            console.error("跨域script请求失败或者请求超时！", ele.src);
            removeEle();
        }
    };
    setTimeout(function () {
        if (window[cbName + "_err"]) {
            window[cbName + "_err"]();
        }
    }, 20000)
    return promise;
}

export async function createUrlJson(olFormat, url, projection) {
    try {
        const response = await jsonp(url, null);
        if (response.error) {
            alert(response.error.message + '\n' +
                response.error.details.join('\n'));
        } else {
            let features = olFormat.readFeatures(response, {
                featureProjection: projection
            });
            return features;
        }
    } catch (e) {
        return Promise.reject(e);
    }
}
